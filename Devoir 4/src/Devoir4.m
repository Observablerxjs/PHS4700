function [xi,yi,zi,face] = Devoir4(nout,nin,depart)    xi = [];  yi = [];  zi = [];  face = [];    pos_ellipsoid = [4,4,11];   rad = 3;  bval = 9;    [polMax polMin azimMax azimMin] = TrouverAngles(depart);    iter_pol = 200;  iter_azim = 200;    pos_initiale = depart;    for dp = 1:iter_pol    for da = 1:iter_azim                      fprintf('FIRST PRINT dp: %d da: %d \n',dp,da);            # calcul des angles du rayon i            pol_n = polMin + ((polMax - polMin)/(2*iter_pol)) * ((2*dp)-1);      azim_m = azimMin + ((azimMax - azimMin)/(2*iter_azim)) * ((2*da)-1);          n1 = nout;      n2 = nin;        nb_reflexion_interne = 0;            # on initialise la variable rayon_dehors a 1 car le rayon est a l'exterieur de l'ellipsoid      rayon_dehors = 1;            # creation du vecteur rayon      rayon_vec = [sin(pol_n) * cos(azim_m), sin(pol_n) * sin(azim_m), cos(pol_n)];                  depart = pos_initiale;      rayon_initiale = rayon_vec;           # premiere verification: Le rayon provenant de l’exterieur ne croise pas le bloc cylindrique transparent. Dans ce cas, le rayon est rejete.      [point_intersection] = intersectionEllipsoidLigne(depart,rayon_vec,pos_ellipsoid, rayon_dehors);            if (!isnan(point_intersection))         # Determiner si rayon n'est pas reflechi        normale = computeNormale(point_intersection,n1,n2,rayon_dehors);                angle_incident = acos(dot(normale,rayon_vec)/(norm(normale)*norm(rayon_vec)));                        # Check si il n'y a pas de reflection totale                isTotalReflection = (n1*sin(angle_incident))/n2;                c2 = 1 - (((n1/n2)^2)*(sin(angle_incident)^2));           if isTotalReflection > 1          continue;        end                # si on arrive a cet instant, ca signifie que le rayon est entré dans l'ellipsoid        rayon_dehors = 0;                angle_de_refraction = asin((n1*sin(angle_incident))/n2);                # inversion des indices de refraction        temp = n1;        n1 = n2;        n2 = temp;                  rayon_vec = ComputeRefraction(rayon_vec,normale,angle_incident,angle_de_refraction);                distance = norm(point_intersection - depart);                collision = 0;                while nb_reflexion_interne <= 100 && !rayon_dehors          depart = point_intersection;                    [IntersectionPoint f] = intersectRectangleLine(depart,rayon_vec);                    if !isnan(f)            collision = 1;            distance = distance + norm(IntersectionPoint - depart);            break          end          [point_intersection] = intersectionEllipsoidLigne(depart,rayon_vec,pos_ellipsoid, rayon_dehors);                     normale = computeNormale(point_intersection,n1,n2,rayon_dehors);                   angle_incident = acos(dot(normale,rayon_vec)/(norm(normale)*norm(rayon_vec)));                    isTotalReflection = (n1*sin(angle_incident))/n2;          c2 = 1 - (((n1/n2)^2)*(sin(angle_incident)^2));                    if abs(isTotalReflection) > 1            # Reflexion            rayon_vec = ComputeReflexion(rayon_vec,normale);          else            rayon_dehors = 1;          endif                              nb_reflexion_interne = nb_reflexion_interne + 1;          distance = distance + norm(point_intersection - depart);           endwhile        if collision            point_image_virtuelle = pos_initiale + (distance * rayon_initiale);            xi = [xi point_image_virtuelle(1)];            yi = [yi point_image_virtuelle(2)];            zi = [zi point_image_virtuelle(3)];            face = [face f];        endif              endif           endfor  endfor  
endfunction
