function [xi,yi,zi,face] = Devoir4(nout,nin,depart)    xi = [];  yi = [];  zi = [];  face = [];    pos_ellipsoid = [4,4,11];   rad = 3;  bval = 9;    [polMax polMin azimMax azimMin] = TrouverAngles(depart);    iter_pol = 200;  iter_azim = 200;    pos_initiale = depart;    for dp = 1:iter_pol    for da = 1:iter_azim            fprintf('FIRST PRINT dp: %d da: %d \n',dp,da);      # calcul des angles du rayon i            pol_n = polMin + ((polMax - polMin)/(2*iter_pol)) * ((2*dp)-1);      azim_m = azimMin + ((azimMax - azimMin)/(2*iter_azim)) * ((2*da)-1);      n1 = nout;      n2 = nin;      nb_reflexion_interne = 0;            # on initialise la variable rayon_dehors a 1 car le rayon est a l'exterieur de l'ellipsoid      rayon_dehors = 1;            # creation du vecteur rayon      rayon_vec = [sin(pol_n) * cos(azim_m), sin(pol_n) * sin(azim_m), cos(pol_n)];            depart = pos_initiale;      rayon_initiale = rayon_vec;            # premiere verification: Le rayon provenant de l’exterieur ne croise pas le bloc cylindrique transparent. Dans ce cas, le rayon est rejete.      [point_intersection] = intersectionEllipsoidLigne(depart,rayon_vec,pos_ellipsoid, rayon_dehors);      ##      test = norm(point_intersection - depart) * rayon_vec;##      quiver3(depart(1),depart(2),depart(3),test(1),test(2),test(3));##      hold on;##      scatter3(point_intersection(1),point_intersection(2),point_intersection(3));##      hold on;            if (!isnan(point_intersection))                # Determiner si rayon n'est pas reflechi        normale = computeNormale(point_intersection,rayon_dehors);                 angle_incident = acos(dot(normale,rayon_vec)/(norm(normale)*norm(rayon_vec)));               # Check si il n'y a pas de reflection totale                isTotalReflection = (n1*sin(angle_incident))/n2;                if abs(isTotalReflection) > 1          fprintf('REFLECTION TOTALE \n');          continue;        end                # si on arrive a cet instant, ca signifie que le rayon est entré dans l'ellipsoid        rayon_dehors = 0;                angle_de_refraction = asin((n1*sin(angle_incident))/n2);                # inversion des indices de refraction        temp = n1;        n1 = n2;        n2 = temp;                # ang_critique = asin(n1/n2);                if n1 != n2          rayon_vec = ComputeRefraction(rayon_vec,normale,angle_incident,angle_de_refraction);        endif                 distance = norm(point_intersection - depart);                collision = 0;                while nb_reflexion_interne <= 100 && !rayon_dehors          #fprintf('nb_reflexion_interne: %d \n',nb_reflexion_interne);                    # check for reflexion interne##          if nb_reflexion_interne != 0##            fprintf('FIRST PRINT dp: %d da: %d \n',dp,da);##            pause;##          endif                    depart = point_intersection;                    [IntersectionPoint f] = intersectRectangleLine(depart,rayon_vec);                    if !isnan(f)            collision = 1;            distance = distance + norm(IntersectionPoint - depart);##            scatter3(IntersectionPoint(1),IntersectionPoint(2),IntersectionPoint(3))##            hold on;            break          end                    [point_intersection] = intersectionEllipsoidLigne(depart,rayon_vec,pos_ellipsoid, rayon_dehors);                           normale = computeNormale(point_intersection,rayon_dehors);                   angle_incident = acos(dot(normale,rayon_vec)/(norm(normale)*norm(rayon_vec)));                    isTotalReflection = (n1*sin(angle_incident))/n2;                    #fprintf('isTotalReflection: %d \n',isTotalReflection);                    if abs(isTotalReflection) > 1            # Reflexion            rayon_vec = ComputeReflexion(rayon_vec,normale);          else            rayon_dehors = 1;          endif                    nb_reflexion_interne = nb_reflexion_interne + 1;          distance = distance + norm(point_intersection - depart);           endwhile                fprintf('****** collision: %d *****\n', collision);                if collision            point_image_virtuelle = pos_initiale + (distance * rayon_initiale);            xi = [xi point_image_virtuelle(1)];            yi = [yi point_image_virtuelle(2)];            zi = [zi point_image_virtuelle(3)];            face = [face f];##            disp(f);##            test = rayon_initiale*dinit;##            quiver3(pos_initiale(1),pos_initiale(2),pos_initiale(3),test(1),test(2),test(3));##            hold on;##            quiver3(depart(1),depart(2),depart(3),rayon_vec(1),rayon_vec(2),rayon_vec(3));##            hold on;##            scatter3(point_image_virtuelle(1),point_image_virtuelle(2),point_image_virtuelle(3));##            hold on;##            pause;        endif              endif           endfor  endfor  
endfunction
